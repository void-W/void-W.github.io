---
layout: post
title: 'python学习笔记 2'
date: 2020-4-26
tags: python
---

### 注释

**多行注释** 如果使用一个三重引号，而且没有将它赋值给一个变量，三重引号之间的所有内容都会被认为是注释。

ps: 如果将三重引号包围的一段字符赋值给某个变量，那么结果会怎样呢？

实际在于行结果如下

```python
>>> note = """a b c"""
>>> note
'a b c'
```

### 关于引号

由以上的运行结果提出一个问题，双引号内的双引号为什么消失了，这里的语法逻辑是什么呢？先来做几个实验寻找一下规律。

```python
>>> str = ""a""
  File "<stdin>", line 1
    str = ""a""
            ^
SyntaxError: invalid syntax
>>> str = ""b""
  File "<stdin>", line 1
SyntaxError: cannot mix bytes and nonbytes literals
>>> str = ""+""
>>> str
''
```

单从结果上来说三重引号等于最简单的一对双引号。而双重引号中我随意填入了一些字符，则出现了各种结果。当然稍微想一下这就是一个很简单的问题，因为直双引号不像括号分左右，所以语法上应该是首先成对的两个引号会被判定成一个字符串。所以`str = ""a""`实际上就变成了两个字符串之间加一个a，而a并不能理解为任何语法符号，所以就报了`invalid syntax`。

但很有意思的是如果中间插入的是b则会报不一样的error。经了解，原来python中在字符串前加某些字母会有特定的含义，如

1. **字符串前加u** 字符串将以Unicode格式进行编码，即不论源码以何种格式储存，字符串都不会出现乱码。
2. **字符串前加r** 禁止字符串的转义机制，常用语正则表达式处理。
3. **字符串前加b** 表示后面的字符串是bytes类型，常用于网络编程。

但认真看一下报错，它的意思是**不能将比特类型的字面量和非比特类型的字面量混合**，所以这个**混合**的操作是哪里来的呢？所以再来做一个实验

```python
>>> str = "a""b"
>>> str
'ab'
```

> 作为一个从c开始学习编程，随后用过erlang和go的程序员不得不说一句python确实是便利。毕竟当初见到可以直接用加号来合并两个字符串的时候我已经感觉相当便利了。

所以明显的，在python中如果两个字符串间不加任何符号（经测试只有空格也可以），然后一起赋值给一个变量，那实际上就会将这两个字符串合并为一个字符串。

那么总结以上，其实就可以来解释一开始的三重字符串的赋值结果了。实际上就一个空字符串加一个非空字符串再加一个空字符床，最终结果自然只剩下那个非空字符串。

#### 遗留问题

1. 上文提到字符串前加b转化为bytes类型常用于网络编程，这很好理解，因为最终发送的都是二进制码。但是我又随手实验了一下

   ```python
   >>> str = b"测试“
     File "<stdin>", line 1
   SyntaxError: bytes can only contain ASCII literal characters.
   ```

   这个结果显然也是意料之中，那么如果想要发送中文字符内容，该怎么处理呢？

2. 实际上我觉得将两个字符串赋值给一个变量时，会将字符串合并，感觉像是将错就错的一种语法糖。因为显然的，如果我按这种逻辑套用到数字上的话

   ```python
   >>> a = 1 2
     File "<stdin>", line 1
       a = 1 2
             ^
   SyntaxError: invalid syntax
   ```

   所以，其实我是不知道python是否像go一样支持在一个等号对多个变量进行赋值的（虽然如果支持的话，其实应该是go是后来者？不过这个问题就不深挖了），但既然都以便利出名了，那应该可以？

   ```python
   >>> a, b = "a" "b"
   >>> a
   'a'
   >>> b
   'b'
   ```

   果然是可以的，而且这时候就不会将两个字符串合并了。并且字符串间加逗号分隔也是可以的。所以关于python赋值语句的规则，应该也会在后续的学习中确认。

